#!/usr/bin/env ruby

require 'pp'
require File.expand_path('candlepin_api', File.dirname(__FILE__) + '/../client/ruby')
require 'optparse'
require 'set'

$field_filter = {
    'include' => [],
    'exclude' => []
}


class CMVCommand
    def initialize(help=nil)
        @cmd_help = help
    end

    def getCommandHelp
        return @cmd_help
    end

    def execute(candlepin, orgs=[], options={})
        raise "Unimplemented method"
    end

    def compileOrgData(candlepin, org)
        org_data = candlepin.get_owner(org)

        org_data['consumers'] = candlepin.list_consumers({:owner => org})
        org_data['pools'] = candlepin.list_pools({:owner => org_data['id']})
        org_data['subscriptions'] = candlepin.list_subscriptions(org)

        product_ids = Set.new

        org_data['pools'].each do |pool|
            product_ids << pool['productId']

            if pool['derivedProductId'] && !pool['derivedProductId'].empty? then
                product_ids << pool['derivedProductId']
            end

            pool['providedProducts'].each do |product|
                product_ids << product['productId']
            end

            pool['derivedProvidedProducts'].each do |product|
                product_ids << product['productId']
            end
        end

        org_data['subscriptions'].each do |subscription|
            product_ids << subscription['product']['id']

            if !subscription['derivedProduct'].nil? && !subscription['derivedProduct'].empty? then
                if subscription['derivedProduct']['id'] && !subscription['derivedProduct']['id'].empty? then
                    product_ids << subscription['derivedProduct']['id']
                end
            end

            subscription['providedProducts'].each do |product|
                product_ids << product['id']
            end

            subscription['derivedProvidedProducts'].each do |product|
                product_ids << product['id']
            end
        end

        products = []

        product_ids.each do |pid|
            product = candlepin.get_product(pid)
            products << product
        end

        org_data['products'] = products

        return org_data
    end
end

class SnapshotCommand < CMVCommand
    def initialize
        super('Creates a snapshot of the products, content and pools for the specified org(s)')
    end

    def execute(candlepin, orgs=[], options={})
        # This may become problematic on deployments with huge amounts of data. If it breaks, maybe
        # look into writing the snapshot smaller files and zipping them all together
        snapshot = {}

        if !File.writable?(File.exists?(options[:file]) ? options[:file] : File.dirname(options[:file])) then
            raise "Cannot write to snapshot file: #{options[:file]}"
        end

        orgs.each do |org|
            puts "Compiling data for org \"#{org}\""
            snapshot[org] = self.compileOrgData(candlepin, org)
        end

        # write snapshot to file
        file = File.new(options[:file], 'w+')
        file.write(JSON.generate(snapshot))
        file.close()

        puts "Snapshot successfully captured and saved to file: #{file.path}"
    end
end

class VerifyCommand < CMVCommand
    def initialize
        super('Verifies the current data for the specified org(s) matches the last/given snapshot')

        @id_cols = {
            'orgs' => 'id',
            'orgs.products' => 'id',
            'orgs.products.productContent' => 'content.id',
            'orgs.products.productContent.content' => 'id',
            'orgs.products.attributes' => 'name',
            'orgs.consumers' => 'uuid',
            'orgs.pools' => 'id',
            'orgs.pools.attributes' => 'name',
            'orgs.pools.branding' => 'productId',
            'orgs.pools.providedProducts' => 'productId',
            'orgs.pools.productAttributes' => 'name',
            'orgs.pools.derivedProvidedProducts' => 'productId',
            'orgs.pools.derivedProductAttributes' => 'name',
            'orgs.subscriptions' => 'id',
        }

        exclude = [
            'orgs.pools.productAttributes.updated',
            'orgs.products.attributes.updated',
            'orgs.products.updated',
            'orgs.products.productContent.content.updated'
        ]

        $field_filter['exclude'].insert($field_filter['exclude'].length, *exclude)
    end

    def execute(candlepin, orgs=[], options={})
        if !File.readable?(options[:file]) then
            raise "Cannot read from snapshot file: #{options[:file]}"
        end

        # Like the note above states, this could be a problem on deployments with huge datasets. We
        # may need to do this with smaller files and not keep everything in memory at once
        file = File.new(options[:file], 'r')
        snapshot = JSON.parse(file.read)
        file.close()

        # TODO: Maybe change this to a has with warning/errors instead of just a flat list of
        # messages?
        messages = []

        orgs.each do |org|
            org_data = self.compileOrgData(candlepin, org)

            result = self.compareObjects("orgs[#{org}]", snapshot[org], org_data)
            messages.insert(messages.length, *result)
        end

        if messages.empty? then
            puts "Deployment successfully verified against snapshot: #{file.path}"
        else
            messages.each do |message|
                puts "\n#{message}\n"
            end

            puts "\nDeployment failed validation against snapshot #{file.path} with #{messages.length} messages\n"
        end
    end

    def getObjIdKey(path, obj)
        path = path.gsub(/\[[^\]]+\]/, '')

        if @id_cols[path] then
            return @id_cols[path].split('.')[0]
        end

        return nil
    end

    def getObjId(path, obj)
        path = path.gsub(/\[[^\]]+\]/, '')

        if @id_cols[path] then
            parts = @id_cols[path].split('.')

            parts.each do |part|
                if obj.is_a?(Hash) then
                    obj = obj[part]
                else
                    obj = nil
                    break
                end
            end

            return obj
        end

        return nil
    end

    def includeField?(path)
        pchunks = path.split('.')

        levels = {}

        $field_filter.each do |key, filter|
            level = 0

            filter.each do |filter_path|
                fchunks = filter_path.split('.')
                match = false
                i = 0

                begin
                    match = pchunks[i] && (pchunks[i].casecmp(fchunks[i]) == 0 ||
                        pchunks[i].gsub(/\[[^\]]+\]/, '').casecmp(fchunks[i]) == 0)

                    i += 1
                end while (match && i < pchunks.length && i < fchunks.length)

                if match && i >= fchunks.length && i > level then
                    level = i
                end
            end

            levels[key] = level
        end

        return (levels['include'] > levels['exclude'] || levels['exclude'] == 0)
    end

    def compareObjects(path, expected, actual)
        messages = []
        exclude = !self.includeField?(path)

        if expected.is_a?(Hash) && actual.is_a?(Hash) then
            keys = Set.new
            keys.merge(expected.keys)
            keys.merge(actual.keys)

            keys.each do |key|
                if !expected.key?(key) then
                    !self.includeField?("#{path}.#{key}") or (messages << "WARNING: Key \"#{key}\" does not exist in snapshot data at: #{path}.#{key}")
                elsif !actual.key?(key) then
                    !self.includeField?("#{path}.#{key}") or (messages << "WARNING: Key \"#{key}\" does not exist in deployment data at: #{path}.#{key}")
                else
                    result = self.compareObjects("#{path}.#{key}", expected[key], actual[key])
                    messages.insert(messages.length, *result)
                end
            end
        elsif expected.is_a?(Array) && actual.is_a?(Array) then
            # How to figure out if these two are identical?
            expected.each do |exp_obj|
                actual.each do |act_obj|
                    if exp_obj.is_a?(Hash) && act_obj.is_a?(Hash) then
                        key = self.getObjIdKey(path, exp_obj)
                        exp_id = self.getObjId(path, exp_obj)
                        act_id = self.getObjId(path, act_obj)

                        if key and exp_id == act_id then
                            expected -= [exp_obj]
                            actual -= [act_obj]

                            result = self.compareObjects("#{path}[#{exp_id}]", exp_obj, act_obj)
                            messages.insert(messages.length, *result)
                        end
                    elsif exp_obj == act_obj then
                        expected -= [exp_obj]
                        actual -= [act_obj]
                    end
                end
            end

            # Check if we have any stragglers in either list
            if !expected.empty? then
                expected.each do |absent|
                    exclude or (messages << "ERROR: Value absent from collection in deployment data at: #{path}\nExpected: #{absent}")
                end
            end

            if !actual.empty? then
                actual.each do |extra|
                    exclude or (messages << "ERROR: New values found in collection in deployment data at: #{path}\nValue: #{extra}")
                end
            end
        elsif actual != expected then
            exclude or (messages << "ERROR: Value mismatch at: #{path}\nExpected: #{expected}\nActual:   #{actual}")
        end

        return messages
    end
end

# setup command map
commands = {
    'snapshot' => SnapshotCommand.new,
    'verify' => VerifyCommand.new
}

def printCommands(commands)
    puts "Commands:"

    commands.each do |cmd_name, command|
        printf("  %-15s   %s\n", cmd_name, command.getCommandHelp)
    end
end

####################################################################################################

# Set up the options
options = {}

optparse = OptionParser.new do |opts|
    file = File.basename(__FILE__)
    opts.banner = "Usage: #{file} [options] <command> [org1 [, org2, [, org3...]]]\n\nOptions:"

    options[:user] = 'admin'
    opts.on('--username [USER]', 'Username to connect as; defaults to "admin".') do |opt|
        options[:user] = opt
    end

    options[:password] = 'admin'
    opts.on('--password [PASSWORD]', 'Password to authenticate the user as; defaults to "admin".') do |opt|
        options[:password] = opt
    end

    options[:server] = 'localhost'
    opts.on('--server [SERVERNAME]', String, 'Server name FQDN; defaults to "localhost"') do |opt|
        options[:server] = opt
    end

    options[:port] = 8443
    opts.on('--port [PORTNUM]', 'Port number for the Candlepin server; defaults to 8443') do |opt|
        options[:port] = opt.to_i
    end

    options[:context] = 'candlepin'
    opts.on('--context [CONTEXT]', 'Context to use; defaults to "candlepin"') do |opt|
        options[:context] = opt
    end

    options[:uuid] = nil
    opts.on('--uuid [UUID]', 'UUID to use; defaults to nil') do |opt|
        options[:uuid] = opt
    end

    options[:ssl] = true
    opts.on('--nossl', 'Do not use SSL; defaults to false') do |opt|
        options[:ssl] = false
    end

    options[:trusted_user] = false
    opts.on('--trusted', 'User should be trusted; defaults to false') do
        options[:trusted_user] = true
    end

    options[:file] = 'snapshot.dat'
    opts.on('-f [FILE]', '--file [FILE]', 'The snapshot file to read/write; defaults to "snapshot.dat"') do |opt|
        options[:file] = opt
    end

    opts.on('-x [EXCLUDE]', '--exclude [EXCLUDE]', 'A field to ignore during verification; may be specified more than once') do |opt|
        $field_filter['exclude'] << opt
    end

    opts.on('-i [INCLUDE]', '--include [INCLUDE]', 'A field to examine during verification, overriding any excludes; may be specified more than once') do |opt|
        $field_filter['include'] << opt
    end

    options[:verbose] = false
    opts.on( '--verbose', 'Enable Verbose Logging' ) do
        options[:verbose] = true
    end

    opts.on('-?', '--help', 'Displays command and option information') do
        puts opts
        puts
        printCommands(commands)
        exit
    end

    opts.on('-c', '--commands', 'Displays the available commands') do
        printCommands(commands)
        exit
    end
end

####################################################################################################

optparse.parse!

if ARGV.empty?
    puts optparse
    exit
else
    candlepin = Candlepin.new(
        options[:user], options[:password], nil, nil, options[:server], options[:port], nil,
        options[:uuid], options[:trused_user], options[:context], options[:ssl]
    )

    candlepin.verbose= options[:verbose]

    cmd_name = ARGV[0]
    command = commands[cmd_name]

    if command.nil? then
        puts "Invalid command or usage\n"
        puts optparse
        exit
    end

    org_list = ARGV[1, ARGV.size]

    if !org_list.empty? then
        # verify specified orgs exist
        org_list.each do |org|
            begin
                result = candlepin.get_owner(org)

                if result.nil? then
                    raise "Invalid org: #{org}"
                end
            rescue
                puts "Invalid org: #{org}"
                exit
            end
        end
    else
        orgs = candlepin.list_owners

        if orgs then
            orgs.each do |org|
                org_list << org['key']
            end
        end
    end

    if !org_list.empty? then
        command.execute(candlepin, org_list, options)
    else
        puts "No orgs to snapshot"
    end
end
